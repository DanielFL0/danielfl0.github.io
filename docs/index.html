<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" type="text/css" href="./style.css" />
  <title>Blog</title>
</head>

<body>
  <div class="container">
    <div class="center">
      <h1 class="title">Rust</h1>
      <p>
        By default, Rust brings only a few <b>types</b> into the scope of every program in the <i>prelude</i>. If a
        <b>type</b> you
        want to use isn't in the prelude, you have to bring that <b>type</b> into scope explicitly with a
        <code>use</code>
        statement.
      </p>

      <h2 class="subtitle">Types</h2>
      <p>
        Every value in Rust is of a certain <i>data type</i>, which tells Rust what kind of data is being specified so
        it
        knows how to work with that data.
      </p>

      <h3>Scalar Types</h3>
      <p>
        A <i>scalar</i> type represents a single value. Rust has four primary scalar types: <b>integers</b>,
        <b>floating-point</b>
        numbers, <b>booleans</b>, and <b>characters</b>.
      </p>

      <h4>Integer Types</h4>
      <p>
        An <i>integer</i> is a number without a fractional component. <i>Signed</i> and <i>unsigned</i> refer to whether
        it's possible for the number to be negative or positive.
        <b>Rust's default integer representation is <code>i32</code></b>
      </p>

      <table>
        <tr>
          <th>Length</th>
          <th>Signed</th>
          <th>Unsigned</th>
        </tr>
        <tr>
          <td>8-bit</td>
          <td><code>i8</code></td>
          <td><code>u8</code></td>
        </tr>
        <tr>
          <td>16-bit</td>
          <td><code>i16</code></td>
          <td><code>u16</code></td>
        </tr>
        <tr>
          <td>32-bit</td>
          <td><code>i32</code></td>
          <td><code>u32</code></td>
        </tr>
        <tr>
          <td>64-bit</td>
          <td><code>i64</code></td>
          <td><code>u64</code></td>
        </tr>
        <tr>
          <td>128-bit</td>
          <td><code>i128</code></td>
          <td><code>u128</code></td>
        </tr>
        <tr>
          <td>arch</td>
          <td><code>isize</code></td>
          <td><code>usize</code></td>
        </tr>
      </table>
      <br>
      <table>
        <tr>
          <th>Number literals</th>
          <th>Example</th>
        </tr>
        <tr>
          <td>Decimal</td>
          <td><code>98_222</code></td>
        </tr>
        <tr>
          <td>Hex</td>
          <td><code>0xff</code></td>
        </tr>
        <tr>
          <td>Octal</td>
          <td><code>0o77</code></td>
        </tr>
        <tr>
          <td>Binary</td>
          <td><code>0b1111_0000</code></td>
        </tr>
        <tr>
          <td>Byte</td>
          <td><code>b'A'</code></td>
        </tr>
      </table>

      <h4>Floating-Point Types</h4>
      <p>
        Rust also has two primitive types for <i>floating-point numbers</i>, which are numbers with decimal points.
        <b>Rust's default floating-point representation is <code>f64</code></b>
      </p>

      <table>
        <tr>
          <th>Length</th>
          <th>Type</th>
        </tr>
        <tr>
          <td>32-bit</td>
          <td><code>f32</code></td>
        </tr>
        <tr>
          <td>64-bit</td>
          <td><code>f64</code></td>
        </tr>
      </table>
      <pre>
        <code>
          fn main() {
              let x = 2.0; // f64
              let y: f32 = 3.0; // f32
          }
        </code>
      </pre>

      <h4>Numeric Operations</h4>
      <p>
        Rust supports the basic mathematical operations you'd expect for all of the number types: <b>addition</b>,
        <b>subtraction</b>, <b>multiplication</b>, <b>division</b>, and <b>remainder</b>.
      </p>

      <pre>
        <code>
          fn main() {
              // addition
              let sum = 5 + 10;
              // subtraction
              let difference = 95.5 - 4.3;
              // multiplication
              let product = 4 * 30;
              // division
              let quotient = 56.7 / 32.2;
              // remainder
              let remainder = 43 % 5;
          }
        </code>
      </pre>

      <h4>Boolean Type</h4>
      <p>
        A <i>boolean</i> type in Rust has two possible values: <code>true</code> and <code>false</code>. Booleans are
        one
        byte in size.
      </p>

      <pre>
        <code>
          fn main() {
              let t = true;
              let f: bool = false;
          }
        </code>
      </pre>

      <h4>Character Type</h4>
      <p>
        Rust's <i>char</i> type is the language's most primitive alphabetic type.
      </p>

      <pre>
        <code>
          fn main() {
              let c = 'z';
              let z = 'Z';
              let heart_eyed_cat = 'ðŸ˜»';
          }
        </code>
      </pre>

      <p>
        Rust's <i>char</i> type is four bytes in size and represents a Unicode Scalar Value, which means it can
        represent
        a lot more than just ASCII. Unicode Scalar Values range from U+0000 to U+D7FF and U+E000 to U+10FFFF inclusive.
      </p>

      <h3>Compound Types</h3>
      <p>
        <i>Compound types</i> can group multiple values into one type. Rust has two primitive compound types:
        <b>tuples</b> and <b>arrays</b>.
      </p>

      <h4>Tuple Type</h4>
      <p>
        A <i>tuple</i> is a general way of grouping together some number of other values with a variety of types into
        one
        compund type. Tuples have a fixed length: once declared, they cannot grow or shrink in size.
      </p>

      <pre>
        <code>
          fn main() {
              let tup: (i32, f64, u8) = (500, 6.4, 1);
              let (x, y, z) = tup;
              println!("The value of y is: {}", y);
              let five_hundred = x.0;
              let six_point_four = x.1;
              let one = x.2;
          }
        </code>
      </pre>

      <h4>Array Type</h4>
      <p>
        Another way to have a collection of multiple values is with an <i>array</i>. Unlike a tuple, every element of an
        array must have the same type. Arrays in rust are different from arrays in some other languages because arrays
        in Rust have a fixed length, like tuples.
      </p>

      <pre>
        <code>
          fn main() {
              let a = [1, 2, 3, 4, 5];
              let months = [
                "January", "February", "March", 
                "April", "May", "June", "July", 
                "August", "September", "October", 
                "November", "December"
              ];
              let a: [i32; 5] = [1, 2, 3, 4, 5];
              let a = [3; 5];
              let a = [3, 3, 3, 3, 3];
              let first = a[0];
          }
        </code>
      </pre>

      <p>
        Arrays are useful when you want your data allocated on the stack rather than the heap or when you want to ensure
        you always have a fixed number of elements.
      </p>

      <p>
        When you attempt to access an element using indexing, Rust will check that the index you've specified is less
        than the array length. If the index is greater than or equal to the length, Rust will panic. This check has to
        happen at runtime.
      </p>

      <h3>Functions</h3>
      <p>
        Functions are pervasive in Rust code. Rust code uses <i>snake case</i> as the conventional style for function
        and variable names. In snake case, all letters are lowercase and underscores separate words.
      </p>

      <pre>
        <code>
          fn main() {
              println!("Hello, world!");
              another_function();
          }

          fn another_function() {
              println!("Another function.");
          }
        </code>
      </pre>

      <p>
        Function definitions in Rust start with <i>fn</i> and have a set of parentheses after the function name. The
        curly brackets tell the compiler where the function body begins and ends.
      </p>

      <p>
        Functions can also be defined to have <i>parameters</i>, which are special variables that are part of a
        function's signature. When a function has parameters, you can provide it with concrete values for those
        parameters. Technically, the concrete values are called <i>arguments</i>, but in casual conversation, people
        tend to use the words <i>parameter</i> and <i>argument</i> interchangeably for either the variables in a
        function's definition or the concrete values passed in when you call a function.
      </p>

      <pre>
        <code>
          fn main() {
              another_function(5);
          }

          fn another_function(x: i32) {
            println!("The value of x is: {}", x);
          }
        </code>
      </pre>

      <p>
        In function signatures, you <i>must</i> declare the type of each parameter. This is a deliberate decision in
        Rust's design: requiring type annotations in function definitions means the compiler almost never needs you to
        use them elsewhere in the code to figure out what you mean.
      </p>

      <pre>
        <code>
          fn main() {
              another_function(5, 6);
          }

          fn another_function(x: i32, y: i32) {
            println!("The value of x is: {}", x);
            println!("The value of y is: {}", y);
          }
        </code>
      </pre>

      <p>
        Function parameters don't need to be the same type.
      </p>

      <h4>Statements and Expressions</h4>
      <p>
        Function bodies are made up of a series of <i>statements</i> optionally ending in an <i>expression</i>. Rust is
        an <i>expression-based</i> language. <i>Statements</i> are instructions that perform some action and do not
        return a value. <i>Expressions</i> evaluate to a resulting value.
      </p>

      <p>
        Creating a variable and assigning a value to it with the <code>let</code> keyword is a statement.
      </p>

      <pre>
        <code>
          fn main() {
              let y = 6;
          }
        </code>
      </pre>

      <p>
        Function definitions are also statements. Statements do no return values. Therefore, you can't assign a
        <code>let</code> statement to another variable, as the following code tries to do; you'll get an error:
      </p>

      <pre>
        <code>
          fn main() {
              let x = (let y = 6);
          }
        </code>
      </pre>

      <p>
        Expressions evaluate to something and make up must of the rest of the code that you'll write in Rust.
        Expressions can be part of statements. The value <code>6</code> is an expression. Calling a function is an
        expression. Calling a macro is an expression. The block that we use to create new scopes, {}, is an expression,
        for example:
      </p>

      <pre>
        <code>
          fn main() {
              let x = 5;

              let y = {
                  let x = 3;
                  x + 1
              };
              println!("The value of y is: {}", y);
          }
        </code>
      </pre>

      <p>
        Expressions do not include ending semicolons. If you add a semicolon to the end of an expression, you turn it
        into a statement, which will then not return a value.
      </p>

      <h4>Return Values</h4>
      <p>
        Functions can return values to the code that calls them. We don't name return values, but we do declare their
        type after an arrow (->). In rust, the return value of the function is synonymous with the value of the final
        expression in the block of the body of a function. You can return early from a function by using the
        <code>return</code> keyword and specifying a value, but most functions return the last expression implicitly.
      </p>

      <pre>
        <code>
          fn five() -> i32 {
              5
          }

          fn main() {
              let x = five();
              println!("The value of x is: {}", x);
          }
        </code>
      </pre>

      <table class="post-list">
        <tbody>
          <tr>
            <td><code>println!</code></td>
            <td>Is a macro that prints a string to the screen.</td>
          </tr>
          <tr>
            <td><code>let</code></td>
            <td>The <code>let</code> statement is used to create a <i>variable</i>.</td>
          </tr>
          <tr>
            <td><code>//</code></td>
            <td>The <code>//</code> syntax starts a comment and continues until the end of the line.</td>
          </tr>
          <tr>
            <td><code>::</code></td>
            <td>The <code>::</code> indicates that the right value is an <i>associated function</i>. Some languages call
              this a <i>static method</i>.</td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</body>

</html>